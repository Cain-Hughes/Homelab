# Week 4 — February 2026

This week I spent some time addressing a few long-standing annoyances in my environment. Nothing particularly dramatic, but the kind of improvements that make day-to-day operation smoother and less fragile.

---

## VPN and Port Forwarding

One area I wanted to revisit involved Gluetun and port forwarding behavior.

I use Gluetun to ensure certain Docker containers communicate exclusively over a VPN tunnel. The container itself has been very reliable, but port forwarding introduced some recurring friction.

I originally used Mullvad VPN and later learned that they do not support port forwarding. While that is not an issue for many use cases, it becomes limiting when running services that benefit from an externally reachable port.

To resolve this, I migrated to Proton VPN. With Gluetun, the forwarded port is exposed through temporary files, which makes it easy to retrieve and use with other services such as qBittorrent.

The workflow functioned as expected, but there was one persistent problem. Whenever the VPN session reset or a container restarted, the forwarded port changed. Each time this happened, I had to manually update the listening port.

That quickly became tedious.

### Automation Approach

My goal was simply to remove the manual step.

I implemented a small Python script that handles the entire process:

- Reads credentials from an environment file  
- Validates or generates an API session cookie  
- Retrieves the current qBittorrent listening port  
- Reads Gluetun’s forwarded port value  
- Compares both values  
- Updates the port when necessary  

The script runs as a cron job every five minutes. In practice, this makes port changes invisible from an operational perspective.

After restarts or VPN reconnections, everything now corrects itself without intervention.  
Here is the script that I used (This script was created using AI assistance with ChatGPT 5.2):  
```python  
#!/usr/bin/env python3
"""
qbt_port_sync.py

Goal:
- Keep qBittorrent's listen_port in sync with Gluetun's forwarded port.

What it does:
1) Tries to call qBittorrent API using a saved cookie (session).
2) If cookie is invalid (403), it logs in using creds from /etc/qbt.env
   and saves a new cookie.
3) Reads current qBittorrent listen_port.
4) Reads forwarded port from /docker/mediabackend/gluetun/tmp/forwarded_port
5) If they differ, updates qBittorrent listen_port via API.

This script is designed to be run repeatedly (cron). It is safe to run often.
"""

import json
from pathlib import Path
import requests


# --- User-editable defaults (you can leave these as-is) ---
ENV_FILE = "/etc/qbt.env"
COOKIE_FILE = "/var/lib/qbt-port-sync/cookie.json"
FORWARDED_PORT_FILE = "/docker/mediabackend/gluetun/tmp/forwarded_port"


def read_env(path: str) -> dict:
    """Very small .env reader: reads KEY=VALUE lines."""
    data = {}
    p = Path(path)
    if not p.exists():
        raise FileNotFoundError(f"Env file not found: {path}")

    for line in p.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        k, v = line.split("=", 1)
        data[k.strip()] = v.strip().strip('"').strip("'")
    return data


def read_forwarded_port(path: str) -> int:
    """Read the forwarded port from Gluetun text file."""
    p = Path(path)
    if not p.exists():
        raise FileNotFoundError(f"Forwarded port file not found: {path}")
    s = p.read_text().strip()
    if not s.isdigit():
        raise ValueError(f"Forwarded port is not a number: {s!r}")
    port = int(s)
    if port < 1 or port > 65535:
        raise ValueError(f"Forwarded port out of range: {port}")
    return port


def load_cookie(session: requests.Session, cookie_file: str) -> None:
    """
    Load cookie from disk into the requests session.
    We store cookies as a simple JSON dict (cookie_name -> value).
    """
    p = Path(cookie_file)
    if not p.exists():
        return
    try:
        cookies = json.loads(p.read_text())
        if isinstance(cookies, dict):
            session.cookies.update(cookies)
    except Exception:
        # If cookie file is corrupted, ignore it; we'll login again.
        pass


def save_cookie(session: requests.Session, cookie_file: str) -> None:
    """Save current session cookies to disk (JSON)."""
    p = Path(cookie_file)
    p.parent.mkdir(parents=True, exist_ok=True)
    cookies = requests.utils.dict_from_cookiejar(session.cookies)
    p.write_text(json.dumps(cookies))


def is_logged_in(session: requests.Session, base_url: str) -> bool:
    """
    Check if cookie is valid by calling an endpoint that requires auth.
    - 200 means logged in
    - 403 means not logged in
    """
    r = session.get(f"{base_url}/api/v2/app/preferences", timeout=10)
    if r.status_code == 200:
        return True
    if r.status_code == 403:
        return False
    raise RuntimeError(f"Unexpected status checking auth: {r.status_code} {r.text[:200]!r}")


def login(session: requests.Session, base_url: str, user: str, pw: str) -> None:
    """
    Log in to qBittorrent and store the SID cookie in the session.
    qBittorrent typically returns 200 with body "Ok." if successful.
    """
    r = session.post(
        f"{base_url}/api/v2/auth/login",
        data={"username": user, "password": pw},
        timeout=10,
    )
    if r.status_code != 200 or "Ok" not in r.text:
        raise RuntimeError(f"Login failed: HTTP {r.status_code} body={r.text[:200]!r}")


def get_listen_port(session: requests.Session, base_url: str) -> int:
    """Fetch current qBittorrent listen_port from preferences."""
    r = session.get(f"{base_url}/api/v2/app/preferences", timeout=10)
    if r.status_code != 200:
        raise RuntimeError(f"Failed to get preferences: HTTP {r.status_code} {r.text[:200]!r}")
    prefs = r.json()
    port = prefs.get("listen_port")
    if not isinstance(port, int):
        raise RuntimeError(f"listen_port not found or not int: {port!r}")
    return port


def set_listen_port(session: requests.Session, base_url: str, port: int) -> None:
    """
    Update qBittorrent listen_port using setPreferences endpoint.
    qBittorrent expects a form field named 'json' containing JSON text.
    """
    payload = {"listen_port": port}
    r = session.post(
        f"{base_url}/api/v2/app/setPreferences",
        data={"json": json.dumps(payload)},
        timeout=10,
    )
    if r.status_code != 200:
        raise RuntimeError(f"Failed to set preferences: HTTP {r.status_code} {r.text[:200]!r}")


def main() -> int:
    # 1) Load creds and base URL from env file
    env = read_env(ENV_FILE)
    base_url = env.get("QBT_URL", "http://127.0.0.1:8080").rstrip("/")
    user = env.get("QBT_USER")
    pw = env.get("QBT_PASS")
    if not user or not pw:
        print("Missing QBT_USER or QBT_PASS in env file.")
        return 2

    # 2) Prepare a session and load any saved cookie
    session = requests.Session()
    load_cookie(session, COOKIE_FILE)

    # 3) Ensure we are logged in; if not, login and save cookie
    try:
        if not is_logged_in(session, base_url):
            login(session, base_url, user, pw)
            save_cookie(session, COOKIE_FILE)
    except Exception as e:
        print(f"[ERROR] Cannot authenticate to qBittorrent: {e}")
        return 3

    # 4) Read both ports
    try:
        forwarded_port = read_forwarded_port(FORWARDED_PORT_FILE)
        current_port = get_listen_port(session, base_url)
    except Exception as e:
        print(f"[ERROR] Cannot read ports: {e}")
        return 4

    # 5) Compare and update if needed
    if current_port == forwarded_port:
        print(f"[OK] Ports match: {current_port}")
        return 0

    try:
        set_listen_port(session, base_url, forwarded_port)
        # quick verify
        new_port = get_listen_port(session, base_url)
        if new_port != forwarded_port:
            raise RuntimeError(f"Verification failed: expected {forwarded_port}, got {new_port}")
        print(f"[CHANGED] Updated listen_port {current_port} -> {forwarded_port}")
        return 0
    except Exception as e:
        print(f"[ERROR] Failed to update listen_port: {e}")
        return 5


if __name__ == "__main__":
    raise SystemExit(main())
```

---

## Storage Migration: SMB to NFS

I also migrated my primary share from SMB to NFS.

This change was driven by some inconsistent file access behavior observed during active seeding. SMB worked well overall, but NFS is generally more predictable in Linux-heavy environments.

Initial results have been encouraging. Permissions and file access patterns appear cleaner, and interactions with containers feel more consistent.

I plan to continue monitoring this change and will document any notable findings in future entries.

---

## Gluetun Health Check Adjustment

One smaller improvement involved refining my Gluetun health check logic.

On rare occasions, the VPN tunnel would establish successfully but no forwarded port would be assigned. From a connectivity standpoint everything looked healthy, yet dependent services would not behave as expected.

To make this failure mode more visible, I modified the health validation to ensure the forwarded port file both exists and contains a valid value.

This provides a more accurate indication of whether the container is fully operational.

---

## Closing Notes

This week’s work centered on reducing manual maintenance and improving reliability. These changes do not alter the architecture in any major way, but they remove small sources of friction that accumulate over time.

As usual, incremental improvements tend to deliver the most noticeable quality-of-life gains.
